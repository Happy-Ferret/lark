use crate::parser::{Token, ParseError};
use crate::parser::grammar_helpers::*;
use crate::parser::ast::*;
use crate::parser::pos::{Span, Spanned};
use crate::parser::program::StringId;
use codespan::ByteIndex;

grammar;

pub Program: Module = {
    PrefixDelim<Item, SEP> => Module::new(<>)
}

Item: Item = {
    Struct => Item::Struct(<>),
    Def => Item::Def(<>)
}

Struct: Struct = {
    <l: @L> struct <name: Identifier> "{" newline* <fields: Fields> "}" <r: @R> => 
        Struct::new(name, fields, Span::from(l, r))
}

Fields: Vec<Field> = {
    <fields: Delim<Field, COMMA>> => fields
}

COMMA = {
    newline* "," newline*
}

COLON = {
    newline* ":" newline*
}

Field: Field = {
    <l: @L> <id: Identifier> ":" <ty: Type> <r: @R> => Field::new(id, ty, Span::from(l, r))
}

Def: Def = {
    <l: @L> def <name: Identifier> <decl: FnDecl> <block: Block> <r: @R> =>
        Def::new(name, decl.0, decl.1, block, Span::from(l, r))
}

FnDecl: (Vec<Field>, Option<Spanned<Type>>) = {
    <params: FnParams> <ty: RetTy?> => (params, ty)
}

FnParams: Vec<Field> = {
    "(" <Delim<Field, COMMA>> ")"
}

RetTy: Spanned<Type> = {
    "->" <Type>
}

Type: Spanned<Type> = {
    <l: @L> <id: Identifier> <r: @R> => Spanned::from(Type::new(None, id), l, r),
    <l: @L> <mode: Mode> <id: Identifier> <r: @R> => Spanned::from(Type::new(Some(mode), id), l, r)
}

Mode: Spanned<Mode> = {
    <l: @L> own <r: @R> => Spanned::from(Mode::Owned, l, r),
    <l: @L> borrow <r: @R> => Spanned::from(Mode::Borrowed, l, r)
}

Block: Block = {
    "{" <PrefixDelim<BlockItem, SEP>> "}" => Block::new(<>)
}

BlockItem: BlockItem = {
    Decl => BlockItem::Decl(<>),
    Expr => BlockItem::Expr(<>)
}

BlockOrIf: BlockOrIf = {
    Block => unimplemented!("BlockOrIf::Block"),
    ExprIf => unimplemented!("BlockOrIf::ExprIf"),
    ExprIfLet => unimplemented!("BlockOrIf::ExprIfLet")
}

Let: Let = {
    let Pat MaybeTypeAscription MaybeInitExpr => unimplemented!("Let")
}

#[inline]
MaybeTypeAscription: () = {
    (":" <Type>)? => unimplemented!("MaybeTypeAscription")
}

#[inline]
MaybeInitExpr: () = {
    ("=" Expr)? => unimplemented!("MaybeInitExpr")
}

Pat: Pattern = {
    "_" => unimplemented!("Pat::_"),
    Identifier => unimplemented!("Pat::Identifier"),
    own Identifier => unimplemented!("Pat::own Identifier")
}

Decl: Declaration = {
    Let => unimplemented!("Expr::Let"),
}

Expr: Expression = {
    Block => unimplemented!("Expr::Block"),
    ExprIf => unimplemented!("Expr::ExprIf"),
    ExprIfLet => unimplemented!("Expr::ExprIfLet"),
    ConstructStruct => Expression::ConstructStruct(<>)
}

ConstructStruct: ConstructStruct = {
    <l: @L> <name: Identifier> "{" <fields: Delim<ConstructField, COMMA>> "}" <r: @R> => ConstructStruct::new(name, fields, Span::from(l, r))
}

ConstructField: ConstructField = {
    Identifier => ConstructField::Shorthand(<>),
    <l: @L> <name: Identifier> ":" newline* <ty: Type> <r: @R> => ConstructField::Longhand(Field::new(name, ty, Span::from(l, r)))
}

ExprIf: Expression = {
    "if" Expr Block => unimplemented!("ExprIf::NoElse"),
    "if" Expr Block "else" BlockOrIf => unimplemented!("ExprIf::Else")
}

ExprIfLet: If = {
    "if" let Pat "=" Expr Block => unimplemented!("ExprIfLet::NoElse"),
    "if" let Pat "=" Expr Block "else" BlockOrIf => unimplemented!("ExprIfLet::Else")
}

ExprAtom: Atom = {
    Lit => unimplemented!("ExprAtom::Lit"),
    PathExpr => unimplemented!("ExprAtom::PathExpr"),
    self => unimplemented!("ExprAtom::Self"),
}

Lit: () = {
    "unimpl" => unimplemented!("Lit")
}

PathExpr: Path = {
    Path<"."> => unimplemented!("PathExpr::Dot"),
    Path<"::"> => unimplemented!("PathExpr::DoubleColon")
}

Identifier: Spanned<StringId> = {
    <l: @L> <id: identifier> <r: @R> => Spanned::from(id, l, r)
}

Path<SEP>: Path = {
    PrefixDelim<Identifier, "::"> => Path::new(<>),
    Delim<Identifier, "::"> => Path::new(<>)
}

// Delimeted list of E with optional trailing delimeter. Potentially
// empty.
Delim<T, SEP>: Vec<T> = {
    <v:(<T> SEP)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

PrefixDelim<T, SEP>: Vec<T> = {
    <d: Delim<T, SEP>> => d,
    SEP <d: Delim<T, SEP>> => d
}

Comma<E> = Delim<E, ",">;

SEP: () = {
    ";",
    Newlines
}

Newlines: () = {
    newline+
}

extern {
    type Location = ByteIndex;
    type Error = ParseError;

    enum Token {
        "_" => Token::Underscore,
        "{" => Token::CurlyBraceOpen,
        "}" => Token::CurlyBraceClose,
        "(" => Token::ParenOpen,
        ")" => Token::ParenClose,
        ":" => Token::Colon,
        ";" => Token::Semicolon,
        "," => Token::Comma,
        "=" => Token::Equals,
        "->" => Token::ThinArrow,
        "::" => Token::DoubleColon,
        "." => Token::Period,
        def => Token::KeywordDef,
        let => Token::KeywordLet,
        struct => Token::KeywordStruct,
        "if" => Token::KeywordIf,
        "else" => Token::KeywordElse,
        own => Token::KeywordOwn,
        borrow => Token::KeywordBorrow,
        self => Token::KeywordSelf,
        while => Token::KeywordWhile,
        loop => Token::KeywordLoop,
        "for" => Token::KeywordFor,
        "unimpl" => Token::Unimplemented,
        identifier => Token::Identifier(<StringId>),
        newline => Token::Newline
    }
}
